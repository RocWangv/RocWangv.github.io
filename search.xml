<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[HTML5学习笔记汇总]]></title>
    <url>%2F2018%2F05%2F21%2FHTML5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[lesson 1 总结预览地址 设置背景图片：12background:url(pic.jpg) center center;background-size:cover; background: #00FF00 url(bgimage.gif) no-repeat fixed top; transform通过设置translateY的值来定位元素在Y轴的位置，如： 1transform:translateY(-50%); text-transform 值 描述 none 默认。定义带有小写字母和大写字母的标准的文本。 capitalize 文本中的每个单词以大写字母开头。 uppercase 定义仅有大写字母。 lowercase 定义无大写字母，仅有小写字母。 inherit 规定应该从父元素继承 text-transform 属性的值。 清除默认间距浏览器会对页面元素有默认的间距值，为了清除它们，一般做法是：1234html,body&#123; margin: 0; padding: 0;&#125; 外部样式文件一般的，我们会在css文件首行增加字符集设置： 1@charset "UTF-8"; 事件拦截通过获取到事件回调的e事件对象，来拦截事件响应：1234function onclick(e)&#123; e.preventDefault(); //TODO&#125; 移动端适配在head中增加： 12&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no,user-scalable=yes,maximum-scale=1.0"&gt; lesson 2 总结预览地址 manifest（离线缓存）通过设置html元素的manifest属性来指定本地缓存配置文件，如： 123&lt;html manifest="cache.manifest"&gt;&lt;!--something else.--&gt;&lt;/html&gt; 在同级目录下的配置文件一般格式为： 1234CACHE MANIFEST/#修改时间：2018-05-11 17:55:35CACHE:index.css 其中，第一行为文件声明，第二行(忽略/，为了转译用)#后面的内容表示注释，CACHE后面是对需要缓存的文件的生命，其后为缓存的文件列表。如果有多个需要缓存的文件，则每一个文件路径都需要各占一行。 在manifest文件中，除CACHE声明哪些文件被缓存外，还有NETWORK和FALLBACK这两个关键字，分别用于声明哪些文件永远不被缓存，以及在无法建立连接的情况下显示的回退页面。此外，CACHE声明也可以被省略。 link（外部链接）、meta（文档元数据）link 显示ico图标： 1&lt;link rel="shortcut icon" type="image/ico" href="favicon.ico"&gt; 将页面添加到iOS设备主屏幕是显示的图标 1&lt;link rel="apple-touch-icon-precomposed" href="apple-touch-icon.png"&gt; 如果不希望iOS系统对图标添加默认的圆角和高粱效果，则可以用apple-touch-icon-precomposed替代apple-touch-icon。如下代码定义了iOS设备中默认的57 x 57及更大的72 x 72主屏图标： 12&lt;link rel="apple-touch-icon-precomposed" href="icon-57.png"&gt;&lt;link rel="apple-touch-icon-precomposed" sizes="72x72" href="icon-72.png"&gt; apple-touch-icon-precomposed按钮文件一般需指定的尺寸包括57 x 57、72 x 72、114 x 114、144 x 144、180 x 180等，并随苹果公司的产品线变化而动态变化。 订阅(rss+xml) 1&lt;link rel="alternate" type="application/rss+xml" title="My Blog" href="rss.xml"&gt; meta 指定浏览器内核。 1&lt;meta name="renderer" content="webkit"&gt; content取值有：webkit：webkit（极速核）。ie-comp:IE兼容内核。ie-stand:IE标准内核。 此外还可以指定IE内核下优先使用最新版本引擎渲染页面，并且可以让安装了Google Chrome Frame扩展插件的浏览器激活Chrome Frame作为渲染引擎，其目的都是表面浏览器使用兼容模式，是页面尽可能以最佳方式呈现： 1&lt;meta name="X-UA-Compatible" content="IE=edge,chrome=1"&gt; 搜索引擎优化（Search Engine Optimization,SEO) 12&lt;meta name="keywords" content="HTML5,前端，代码，样式"&gt; &lt;meta name="description" content="这是一个HTML5开发的前端页面"&gt; 移动端浏览器处理不希望页面中的数字自动识别为电话号码，从而显示为拨号的超链接： 1&lt;meta name="format-detection" content="telephone=no"&gt; content还有email=no等取值 lesson 3 总结DEMO预览地址 line-height（行高）与大多数CSS属性不同，line-height支持属性值设置为无单位的数字。有无单位在子元素继承属性时有微妙的不同。 语法 line-height: normal | | | normal 根据浏览器决定，一般为1.2。number 仅指定数字时（无单位），实际行距为字号乘以该数字得出的结果。可以理解为一个系数，子元素仅继承该系数，子元素的真正行距是分别与自身元素字号相乘的计算结果。大多数情况下推荐使用，可以避免一些意外的继承问题。length 具体的长度，如px/em等。percentage 百分比，100%与1em相同。 有单位（包括百分比）与无单位之间的区别有单位时，子元素继承了父元素计算得出的行距；无单位时继承了系数，子元素会分别计算各自行距（推荐使用）。 由此可以得出demo页面的三种计算方式： 百分比：父元素的行高为150%时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。所以当line-height:150%时，字元素的行高等于16px * 150% = 24px em：父元素的行高为1.5em时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。所以当line-height:1.5em时，子元素的行高等于16px * 1.5em = 24px 无单位：父元素行高为1.5时，会根据子元素的字体大小动态计算出行高值让子元素继承。所以，当line-height:1.5时，子元素行高等于30px * 1.5 = 45px 总的来说，当父元素行高为百分比和em时，会根据父元素的字体大小先计算出行高值然后再让子元素继承。当父元素行高为无单位情况下，会根据子元素的字体大小动态计算出行高值让子元素继承。 参考地址：CSS:line-height:150%与line-height:1.5的真正区别是什么？ float (浮动)由于浮动的设置，两个块级元素不在各占一行，而是在同一行中一起显示。如果希望两个仍各占一行，则可以用clear属性来清楚浮动。其中设置该属性的值为both时，表示在元素的左右两侧均不允许浮动元素。 123*&#123; clear:both;&#125; 具体请通过预览DEMO来观察。 text-shadow、box-shadow12text-shadow:x y deg color;box-shadow:x y deg speed color inset/outset; 样式优先级 由低到高 通用选择器。如*{...} 标签选择器。如h1{...} 类选择器。如.nav{...} 伪类选择器。如a:hover{...} 、 li:first-child{...} ID选择器。如#title{...} 行间样式。如&lt;div style = &quot;color:red;&quot;&gt;&lt;/div&gt; lesson 4 总结DEMO预览地址 终于迎来了我喜欢的 javascript 环节了呢，嘻嘻~ console12345console.log(msg); //正常显示console.error(msg); //淡红底色并带有错误标志console.info(msg);// 正常console.debug(msg);// 调试信息console.warn(msg);// 淡黄色底色并带有警告标志 tip: 在Console窗口中要为代码换行时，可以使用Shift+Enter组合键。 function 立即执行函数 (IIFE: Immediately Invoked Function Expression) 如果定义了一个匿名函数且没有将其赋予某个变量，要执行这个匿名函数，则可以采用(function(){})()的代码格式。其中前一个括号里面是匿名的函数，后一个括号中是传入的参数，如果没有参数则括号中的内容可以为空，代码如下： 123(function(name)&#123; console.log('My name is '+name);&#125;)('Roc') //输出 My name is Roc 当然，也有其他写法，如： 123(function(name)&#123; console.log('My name is '+name);&#125;('Roc')) //输出 My name is Roc 和 123!function(name)&#123; console.log('My name is '+name);&#125;('Roc') //输出 My name is Roc 简单来说，IIFE的作用在于使得函数在被载入时自动执行，同时利用匿名函数和闭包的特性形成一个独立的作用域，将内部所有的变量封闭起来，使其不会影响到函数外部的其他变量。 cancelBubble 和 stopPropagation 可以参考DEMO中的应用来理解 事实上stopPropagation和cancelBubble的作用是一样的，都是用来阻止浏览器默认的事件冒泡行为。不同之处在于stopPropagation属于W3C标准，试用于Firefox等浏览器，但是不支持IE浏览器。相反cancelBubble不符合W3C标准，而且只支持IE浏览器。所以很多时候，我们都要结合起来用。不过，cancelBubble在新版本chrome,opera浏览器中已经支持。所以，一般我们都写作： 123elem.onclick = function(e)&#123; window.event ? e.cancelBubble = true : e.stopPropagation();&#125; 另外，jquery的stopPropagation()已经做了兼容性处理： 12345678910111213141516jQuery.Event.prototype = &#123; stopPropagation: function() &#123; this.isPropagationStopped = returnTrue; var e = this.originalEvent; if ( !e ) &#123; return; &#125; // if stopPropagation exists run it on the original event if ( e.stopPropagation ) &#123; e.stopPropagation(); &#125; // otherwise set the cancelBubble property of the original event to true (IE) e.cancelBubble = true; &#125;&#125; 参考网址：Event.cancelBubble - Web APIs | MDN lesson 5 总结DEMO预览地址 viewportviewport 翻译为中文可以叫做”视区”。手机浏览器是把页面放在一个虚拟的”窗口”（viewport）中，通常这个虚拟的”窗口”（viewport）比屏幕宽，这样就不用把每个网页挤到很小的窗口中（这样会破坏没有针对手机浏览器优化的网页的布局），用户可以通过平移和缩放来看网页的不同部分。 一个常用的 viewport meta 如下： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; width：控制 viewport 的大小，可以指定的一个值，如 600，或者特殊的值，如 device-width 为设备的宽度（单位为缩放为 100% 时的 CSS 的像素）。 height：和 width 相对应，指定高度。 initial-scale：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale：允许用户缩放到的最大比例。 minimum-scale：允许用户缩放到的最小比例。 user-scalable：用户是否可以手动缩放。 vw vhvw 相对于视窗(viewport)的宽度：视窗宽度是100vwvh 相对于视窗(viewport)的高度：视窗高度是100vhvmin 和 vmax 自动选择相对于viewport宽高而言最小或者最大的制 换算：5vw = 屏幕宽度的1/20，即为5%，当屏幕宽度为400px时，字体大小为20px； 弹性布局 为父元素增加display 12display:flex;display:-webkit-flex; /* webkit内核浏览器的兼容写法 */ flex-direction取值有： 123row 横向布局 默认取值column 纵向布局column-reverse 纵向反向排列 flex 12flex : 1 1 auto;-webkit : 1 1 auto; flex属性的三个参数分别为： flex-grow : 决定伸缩元素可扩展空间的分配，在此为1，表示每个元素的可扩展空间大小相等； flex-shrink : 定义当元素超过容器的大小后的压缩比例，在此为1，即每隔元素的亚索能力相同； flex-basis : 定义伸缩的基准值，在此为auto，即自动分配空间。 CSS Sprite 雪碧图 CSS雪碧的基本原理是把你的网站上用到的一些图片整合到一张单独的图片中，从而减少你的网站的HTTP请求数量。该图片使用CSS background和background-position属性渲染，这也就意味着你的标签变得更加复杂了，图片是在CSS中定义，而非标签。 12345678a &#123; display:block; width:200px; height:65px; line-height:65px; /*定义状态*/ text-indent:-2015px; /*隐藏文字*/ background-image:url(button.png); /*定义背景图片*/ background-position:0 0; /*定义链接的普通状态，此时图像显示的是顶上的部分*/ &#125;a:hover &#123;background-position:0 -66px; /*定义链接的滑过状态，此时显示的为中间部分，向下取负值*/&#125;a:active &#123;background-position:0 -132px; /*定义链接的普通状态，此时显示的是底部的部分，向下取负值*/&#125; Icon Font 图标字体自定义字体： 1234@font-face &#123;font-family: 'roc-font';src:url('roc-iconfont.ttf'),url('roc-iconfont.eot'),url('roc-iconfont.woff');&#125; 实际使用： 1234h1:before&#123; font-family: 'roc-font'; content:'\e626'; /* 来自于自定义字体的unicode编码 */&#125; 一些移动端开发技巧 当用户在iOS设备中按住一个页面元素时，iOS会自动在元素周围显示橙色的外框，表示钙元素被按中，这一高亮效果可以用下面代码去除 123*&#123; -webkit-tap-highlight-color: rgba(0,0,0,0); /* 设为透明 */&#125; 以上代码还可以解决在一些Android机型中，单击后发生被绑定单击区域闪一下的问题。 以下代码可以避免在横竖屏幕切换时，移动设备对页面的文字大小进行自动调整： 12345html&#123; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; text-size-adjust: 100%;&#125; 当页面高度设置为100%是，去除系统自带的导航栏高度的方法： 1document.documentElement.style.height = window.innerHeight + 'px'; 获取用户设备类型 1console.log(navigator.userAgent) 获取设备的网络连接类型, ethernet, wifi,2G,3G,4G … 1navigator.connection.type 获取设备的横竖屏状态 1window.orientation || screen.orientation 用户在使用iOS设备从主屏幕直接启动某个页面时，显示一副启动图： 1&lt;link rel="apple-touch-startup-image" href="default.png" /&gt; 当站点有配套的Apple Store APP时，可以通过添加名为Smart App Banners 的 meta 标签，将应用链接（下载条幅）显示在页面顶部，方便用户下载使用 1&lt;meta name="apple-itunes-app" content="app-idd=547523434" /&gt; lesson 6 总结 本节课主要学习是布局相关知识。 两列均分布局| 格子布局| 格子布局 - 跨行 清除浮动12345section::after&#123; content: ''; display:table; clear:both;&#125; 但是老版本IE并不支持::after伪元素，可以采用手动插入一段DOM结构的方式来清除浮动。一般的，一个常用的清除浮动的类就可以写作： 1234567.clearfix:before, .clearfix:after&#123; content:''; display: table;&#125;.clearfix:after&#123; clear:both;&#125; 使用时： 1&lt;section class="clearfix"&gt;...&lt;/section&gt; 需要补充说明的是，将display属性设置为table，并设置clear为both，是为了使清除浮动的时候形成一种名为BFC（Block Format Content, 块级格式化上下文） 的机制。在BFC中，元素布局不收外界的影响，我们往往利用该特性来清除浮动元素对其他非浮动元素带来的影响。此外，在BFC中，块级元素与由行内元素组成的”行盒子”会垂直的沿其父元素的边框排列。触发BFC的因素很多，如上述设置display为table即为其中的一种因素（也可以设置display为inline-block、table-cell、table-caption、flex、inline-flex等）。而且，overflow不为visible也会触发BFC。 overflow触发BFC的Demo box-shadow 设置框线为元素顶部绘制一条1像素宽，颜色为40%透明度黑色的边框： 1box-shadow:0 0 1px rgba(0,0,0,.4) inset; 布局总结：如Demo中所体现出来的，无论什么布局都可以使用百分比布局来实现： 规定其父元素的固定宽度（或者最小宽度）； 设置其子元素的宽度为对应的百分比（如两列均等布局，宽度分别为50%）； 设置子元素的float(浮动)； 为了防止高度”坍塌”，清除父元素浮动。 lesson 7 总结两列自适应布局 | 三列自适应布局（圣杯布局） | 三列自适应布局（淘宝UED - 双飞翼布局） | 瀑布流布局） 本节课主要学习了高阶布局相关的知识，并深入理解了relative（相对布局）和absolute（绝对布局） 参考网址：css-相对绝对定位系列（一） —— 张鑫旭的博客 lesson 8 总结transition demo | animation demo1 - 会旋转的图标 | animation demo2 - 会移动的一排图标 | animation demo3 - cubic bezier 动画与特效 transitiontransition 属性是一个简写属性，用于设置四个过渡属性： transition-property transition-duration transition-timing-function transition-delay 注释：请始终设置 transition-duration 属性，否则时长为 0，就不会产生过渡效果。 默认值： all 0 ease 0 值 描述 transition-property 规定设置过渡效果的 CSS 属性的名称。 transition-duration 规定完成过渡效果需要多少秒或毫秒。 transition-timing-function 规定速度效果的速度曲线。默认 ease transition-delay 定义过渡效果何时开始。 属性取值： transition-property : all none 或者其他的属性值，如：width background 等 transition-duration : 0.5s 5000ms transition-timing-function : ease linear ease-in ease-out ease-in-out transition-delay 0s 一般用法： 123transition: all 0.5s;transition: color 0.5s linear; 组合用法： 1transition: color 0.5s linear, background .5s ease-in-out 1s; animationanimation 属性是一个简写属性，用于设置六个动画属性： 值 描述 animation-name 规定需要绑定到选择器的 keyframe 名称。 animation-duration 规定完成动画所花费的时间，以秒或毫秒计。 animation-timing-function 规定动画的速度曲线。默认 ease animation-delay 规定在动画开始之前的延迟。 animation-iteration-count 规定动画应该播放的次数。 animation-direction 规定是否应该轮流反向播放动画。 注释：请始终规定 animation-duration 属性，否则时长为 0，就不会播放动画了。 animation-fill-modeanimation-fill-mode 属性规定动画在播放之前或之后，其动画效果是否可见。注释：其属性值是由逗号分隔的一个或多个填充模式关键词。 语法: 1animation-fill-mode : none | forwards | backwards | both; 值 描述 none 不改变默认行为。 forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）。 backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both 向前和向后填充模式都被应用。 参考网址： 理解animation-fill-mode属性如何理解animation-fill-mode及其使用？ 为动画添加 cubic-bezier （三次贝塞尔）函数通过 cubic-bezier 网站来生成三次贝塞尔曲线函数，然后添加到animation后： 1234.icon&#123; animation: move 1s cubic-bezier(.51,-1.09,.39,1.89); -webkit-animation: move 1s cubic-bezier(.51,-1.09,.39,1.89);&#125; lesson 9 总结 页面切换动效 横向平移特效 | 纵向平移特效 | 缩小放大特效 | 水平翻转特效 | 翻转加缩放 Loading 动效 简单loading | 带有拖尾效果的loading | 横向 dot loading | circle dot loading 翻书动效 | book paging Meta http-equiv属性http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 meat标签的http-equiv属性语法格式是：＜meta http-equiv=”参数” content=”参数变量值”＞ 12&lt;meta http-equiv="Page-Enter" content="revealTrans(duration=1.0,transtion=12)"&gt;&lt;meta http-equiv="Page-Exit" contect="revealTrans(duration=1.0,transtion=12)"&gt; Duration的值为网页动态过渡的时间，单位为秒。Transition是过渡方式，它的值为0到23，分别对应24种过渡方式。如下表： 1234567891011120 盒状收缩 1 盒状放射 2 圆形收缩 3 圆形放射 4 由下往上 5 由上往下 6 从左至右 7 从右至左 8 垂直百叶窗 9 水平百叶窗 10 水平格状百叶窗 11 垂直格状百叶窗 12 随意溶解 13 从左右两端向中间展开 14 从中间向左右两端展开 15 从上下两端向中间展开 16 从中间向上下两端展开 17 从右上角向左下角展开 18 从右下角向左上角展开 19 从左上角向右下角展开 20 从左下角向右上角展开 21 水平线状展开 22 垂直线状展开 23 随机产生一种过渡方式 CSS3 perspective 属性 浏览器支持 目前浏览器都不支持 perspective 属性。Chrome 和 Safari 支持替代的 -webkit-perspective 属性。 定义和用法 perspective 属性定义 3D 元素距视图的距离，以像素计。该属性允许您改变 3D 元素查看 3D 元素的视图。当为元素定义 perspective 属性时，其子元素会获得透视效果，而不是元素本身。 注释：perspective 属性只影响 3D 转换元素。 1perspective: number|none; CSS3 backface-visibility 属性backface-visibility 属性定义当元素不面向屏幕时是否可见。如果在旋转元素不希望看到其背面时，该属性很有用。 1backface-visibility: visible|hidden; before 与 after 伪元素一个小知识点：after伪元素默认的显示层级高于before伪元素。 transform-origintransform-origin 属性允许您改变被转换元素的位置。2D 转换元素能够改变元素 x 和 y 轴。3D 转换元素还能改变其 Z 轴。 1transform-origin: x-axis y-axis z-axis; 参考网址：CSS3 transform-origin 属性 lesson 10 总结DEMO预览地址 canvascanvas本身没有绘图能力，需要通过它的getContext()方法来返回可绘图的对象。 清除画布区域： 1context.clearRect(0,0,window.innerWidth,window.innerHeight); Canvas中的arc()方法可用于创建原型形状，它的几个参分别代表圆心的x坐标、y坐标、半径、起始角度和结束角度。其中角度的单位是”弧度”而非”角度”，因此要绘制一个完整的原型，其起始角度为0，结束角度应为2π。 1context.arc(100, 100, 5, 0, Math.PI * 2); 随机颜色1'#'+('000000'+(Math.random()*0x1000000&lt;&lt;0).toString(16)).slice(-6) GSAP带缩略效果的飞机会旋转的飞机矩形变圆形盒子横向展开效果 更多介绍见Github:GreenSock-JS]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解__proto__和prototype]]></title>
    <url>%2F2018%2F05%2F10%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3prototype%2F</url>
    <content type="text"><![CDATA[最近在收集面试题的时候发现了一些考查prototype的题目，然而很多都是一知半解的看完了，今天就深入理解一下prototype和proto 。 1注：由于hexo模板编译问题，文中的粗体proto均为__proto__. 首先要明确的是： 在JS里，万物皆对象。方法（Function）是对象，方法的原型(Function.prototype)是对象。因此，它们都会具有对象共有的特点。即：对象具有属性proto，可称为隐式原型，一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。如：123456789function Person()&#123;&#125;Person.prototype.name = 'Roc';Person.prototype.getName = function()&#123; return this.name;&#125;console.log(Person.prototype);//&#123;name: "Roc", getName: ƒ, constructor: ƒ&#125;var p = new Person();console.log(p.__proto___);//&#123;name: "Roc", getName: ƒ, constructor: ƒ&#125;console.log(p.constructor.prototype);//&#123;name: "Roc", getName: ƒ, constructor: ƒ&#125; 由此可以得出以上结论，以及：1instance.constructor.prototype = instance.__proto__ 方法(Function)这个特殊的对象，除了和其他对象一样有上述proto属性之外，还有自己特有的属性——原型属性（prototype），这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。原型对象也有一个属性，叫做constructor，这个属性包含了一个指针，指回原构造函数。 好啦，知道了这两个基本点，我们来看看上面这副图。 构造函数Foo()构造函数的原型属性Foo.prototype指向了原型对象，在原型对象里有共有的方法，所有构造函数声明的实例（这里是f1，f2）都可以共享这个方法。 原型对象Foo.prototypeFoo.prototype保存着实例共享的方法，有一个指针constructor指回构造函数。 实例f1和f2是Foo这个对象的两个实例，这两个对象也有属性proto，指向构造函数的原型对象，这样子就可以像上面1所说的访问原型对象的所有方法啦。 另外：构造函数Foo()除了是方法，也是对象啊，它也有proto属性，指向谁呢？指向它的构造函数的原型对象呗。函数的构造函数不就是Function嘛，因此这里的proto指向了Function.prototype。其实除了Foo()，Function(), Object()也是一样的道理。原型对象也是对象啊，它的proto属性，又指向谁呢？同理，指向它的构造函数的原型对象呗。这里是Object.prototype.最后，Object.prototype的proto属性指向null。&gt; 总结： 对象有属性proto,指向该对象的构造函数的原型对象。 方法除了有属性proto,还有属性prototype，prototype指向该方法的原型对象。 （本文系转载）作者：doris链接：https://www.zhihu.com/question/34183746/answer/58155878来源：知乎]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数柯里化]]></title>
    <url>%2F2018%2F04%2F03%2F%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 以上是来自维基百科的名词解释，有点绕。简而言之，柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。 先来看一下柯里化的通用实现：12345678function currying(fn) &#123; var slice = Array.prototype.slice, __args = slice.call(arguments, 1); return function () &#123; var __inargs = slice.call(arguments); return fn.apply(null, __args.concat(__inargs)); &#125;; &#125; 解读一下这段代码： line 2 &amp; line 3 : Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组，除了IE下的节点集合（因为ie下的dom对象是以com对象的形式实现的，js对象与com对象不能进行转换），所以这里是除了fn之外的参数全部转化为了数组 接下来的 line 4/5/6/7 其实是返回了一个闭包 line 5 将闭包函数内的参数转化为数组 __inargs line 6 执行传入的fn函数，其参数为两次传入参数的集合 注：当apply传入null/undefined为第一个参数的时候将执行js全局对象，浏览器中是window，其他环境是global。 柯里化的实用性提现在很多方面： 1 提高适用性根据以上代码我们来做一个简单的实现： 12345678910111213141516171819202122function apple(sth)&#123; console.log(`apple $&#123;sth&#125;`);&#125;function pineapple(sth)&#123; console.log( `pineapple $&#123;sth&#125;`);&#125;function map(handler,list)&#123; return list.map(handler);&#125;//数据的每一项进行遍历拼接map(apple, ['pen','watch','phone']);map(pineapple, ['pen','watch','phone']);//加入 柯里化 实现后,可以看到和上面的结果是一致的var mapApple = currying(map, apple);mapApple(['pen','watch','phone']);var mapPine = currying(map, pineapple);mapPine(['pen','watch','phone']); 由此，可知柯里化不仅仅是提高了代码的合理性，更重的它突出一种思想—降低适用范围，提高适用性。 2 延迟执行柯里化的另一个应用场景是延迟执行。不断的柯里化，累积传入的参数，最后执行。以下是其通用写法：12345678910var curry = function(fn) &#123; var _args = [] return function cb() &#123; if (arguments.length == 0) &#123; return fn.apply(this, _args) &#125; Array.prototype.push.apply(_args, arguments); return cb; &#125;&#125; 3 固定易变因素柯里化特性决定了它这应用场景。提前把易变因素，传参固定下来，生成一个更明确的应用函数。最典型的代表应用，是bind函数用以固定this这个易变对象。 12345678Function.prototype.bind = function(context) &#123; var _this = this, _args = Array.prototype.slice.call(arguments, 1); return function() &#123; return _this.apply(context, _args.concat(Array.prototype.slice.call(arguments))) &#125;&#125;]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习笔记一]]></title>
    <url>%2F2018%2F03%2F27%2F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[使用正则和replace实现千位分隔符 1'1234567890'.replace(/\B\d&#123;3&#125;/g,',$&amp;’); css3 中使图片变色的方式：filter(gray) css3 中的动态计算函数：calc() = calc(四则运算)，需要注意的是，运算符前后都需要保留一个空格 , 例如： 1width: calc(100% - 10px) 100vh表示屏幕内部高度，100vw表示屏幕内部宽度 怎么让Chrome支持小于12px 的文字 1p&#123;font-size:10px;-webkit-transform:scale(0.8);&#125;//0.8是缩放比例 如果需要手动写动画，你认为最小时间间隔是多久 1多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 如何判断一个对象是否属于某个类？ 1使用instanceof 即if(a instanceof Person)&#123;alert('yes');&#125; 写一个通用的事件侦听器函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677// event(事件)工具集，来源：github.com/markyunRocWang.Event = &#123;// 页面加载完成后 readyEvent: function (fn) &#123; if (fn == null) &#123; fn = document; &#125; var oldonload = window.onload; if (typeof window.onload != 'function') &#123; window.onload = fn; &#125; else &#123; window.onload = function () &#123; oldonload(); fn(); &#125;; &#125; &#125;,// 视能力分别使用dom0||dom2||IE方式 来绑定事件// 参数： 操作的元素,事件名称 ,事件处理程序 addEvent: function (element, type, handler) &#123; if (element.addEventListener) &#123;//事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); &#125; else if (element.attachEvent) &#123; element.attachEvent('on' + type, function () &#123; handler.call(element); &#125;); &#125; else &#123; element['on' + type] = handler; &#125; &#125;,// 移除事件 removeEvent: function (element, type, handler) &#123; if (element.removeEnentListener) &#123; element.removeEnentListener(type, handler, false); &#125; else if (element.datachEvent) &#123; element.detachEvent('on' + type, handler); &#125; else &#123; element['on' + type] = null; &#125; &#125;,// 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation: function (ev) &#123; if (ev.stopPropagation) &#123; ev.stopPropagation(); &#125; else &#123; ev.cancelBubble = true; &#125; &#125;,// 取消事件的默认行为 preventDefault: function (event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;,// 获取事件目标 getTarget: function (event) &#123; return event.target || event.srcElement; &#125;,// 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent: function (e) &#123; var ev = e || window.event; if (!ev) &#123; var c = this.getEvent.caller; while (c) &#123; ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) &#123; break; &#125; c = c.caller; &#125; &#125; return ev; &#125;&#125;;]]></content>
      <categories>
        <category>FE</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017年终总结]]></title>
    <url>%2F2018%2F02%2F10%2F2017%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[动荡的一年。 &emsp;&emsp;每到临近年终，心里都有一种失落的感觉，这种失落感既来于年初给自己定的目标很多没有实现，也源于在很多机遇来临的时候没有好好把握。 &gt; 外部因素：16年底进入的元银在17年初黄了，被老东家丰瑞祥召回，屋漏偏逢连夜雨，丰瑞祥在10月份资金链断裂，发不出工资，大批量裁员，我也离职了，来到了文思。 &gt; 工作方面：在技术的成长反面，今年是我进步最慢的一年，对自己十分不满意。做了一年的RN+react，想起去年给自己定下要征服android，迈进全栈的计划，对自己失望。 使用RN &amp; react-navigation &amp; redux封装了一个脚手架，比起官网例子更简单易懂，目前在github上的star 达到21个。 学习mobx的过程中，使用RN &amp; mobx &amp; react-native-router-flux开发了一个简单的APP (ASimpleApp),也开源在了GitHub。 使用react重构了公司原来的前端框架，并开源了自己使用node部署react/vue项目的服务端部署方案。 &gt; 生活方面： 还是单身狗，汪汪汪！！！！！！ 学会了红烧肉，大盘鸡，学会了做鱼。 几乎要放弃LOL了，吃鸡真好玩！ 一个人的日子过够了啊！ 学会了滑板，虽然快被摔死了，虽然右腿膝盖上留下了一块很大的疤痕。 自己的脾气今年有好那么一点点，学会克制。 &gt; 新年寄语： 改改自己的臭脾气吧，不然真的孤独终老了！ 致力于学习原生JS和nodeJs，至少要看三本技术方面的书，并且po出读书笔记！ 一！定！要！勤跑步，经常运动，不要做一个死肥宅了啊！ 晚上十二点之前一定要睡觉啊，奔三了啊，身体不比当年了啊！ 碰见喜欢的女孩子，一定要勇敢一点表达出来啊！ 总之吧，新的一年，新的开始，一定要比去年好，要有长足的进步，不要让明年写年终总结的时候又这样尴尬的凑字了啊啊啊！！]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>又是一年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react项目在服务端部署方案]]></title>
    <url>%2F2017%2F08%2F11%2Freact%E9%A1%B9%E7%9B%AE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一、环境搭建1、node 环境安装 登录到你的linux服务器上（针对于64位的服务器来说），然后在当前目录依次执行： 123456789cd /usr/localmkdir nodecd nodewget https://nodejs.org/dist/v6.11.2/node-v6.11.2-linux-x64.tar.xzxz -d node-v6.11.2-linux-x64.tar.xztar xvf node-v6.11.2-linux-x64.tarmv node-v6.11.2-linux-x64 node-v6.11.2ln -s /usr/local/node/node-v6.11.2/bin/node /usr/local/bin/nodeln -s /usr/local/node/node-v6.11.2/bin/npm /usr/local/bin/npm 至此，node环境已经安装完毕，可以通过node -v来检查是否安装成功。 2、配置node环境变量 很重要！ 如果不配置环境变量，有些通过npm安装的CLI会找不到。 首先进入配置文件： 1vi /etc/profile 按 i 键进入编辑模式，进入文件末尾添加： 12export NODE_HOME=/usr/local/node/node-v6.11.2/binexport PATH=$NODE_HOME:$PATH 然后按 ESC 键 ，在控制台输入:wq，回车保存退出。 注：具体的NODE_HOME路径来自第一步你的node安装的目录。 3、安装pm2模块 pm2 是一个带有负载均衡功能的Node应用的进程管理器. 执行： 1npm install -g pm2 执行成功后，断开当前用户的服务器连接，然后重新登录。 二、 项目编译1、生成项目的根目录可以通过命令行或者手动创建的方式生成项目根目录，如： 1mkdir merchant-center 可以将merchant-center替换成你自己的项目名称。 2、配置express环境将该文档的同级目录下的app.js和package.json两个文件放在你上一步生成的项目根目录下，然后执行： 1npm install 确保当前目录下生成node_modules文件夹。 3、生成项目的部署文件 在你的react项目根目录下执行： 1npm run build 成功后，会生成dist目录，该目录的内容就是你要部署到服务器上的文件。 你可以通过： 1sup [-r] [-P port] 源路径 user@目标IP地址:目标路径 或者直接通拽的方式将该目录内容放置服务器上，然后将dist放在第一步生成的项目根目录下。此时，项目的目录结构应该是： 12345merchant-center //或其他项目名称 |____app.js //可以打开修改里面的3000端口号 |____dist //项目生成的静态文件（不要重命名！） |____node_modules //express的依赖模块 |____package.json 三、项目启动首先确保你已经按照本文档执行了以上的所有步骤。然后在项目的根目录下执行： 1pm2 start app.js 当你看到了这样的日志输出的时候，说明你已经启动成功了！ 另外，pm2的其他命令行参考： 123456789101112pm2 start app.js # 项目启动pm2 stop all # 停止所有pm2启动的应用pm2 stop 0 # 停止进程id为0的进程pm2 restart all # 重启所有应用pm2 reload all # 0延迟重新加载pm2 list # 列出所有用pm2启动的进程pm2 monit # 显示每一个应用的内存和cpu使用情况pm2 show [app-name] # 显示当前应用的所有信息pm2 logs # 显示所有应用的日志pm2 logs [app-name] # 显示当前应用的日志pm2 logs --json # 以json格式展示日志 更多操作命令可以去pm2官网或者其github查看。 至此，项目已经部署完成啦！ Open your browser , Enjoy it !]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>服务端部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native开发过程中踩过的坑]]></title>
    <url>%2F2017%2F08%2F07%2Freact-native%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[0、Could not install the app on the device, read the error above for details.123456789101112jax$ react-native run-androidStarting JS server...Building and installing the app on the device (cd android &amp;&amp; ./gradlew installDebug...Could not install the app on the device, read the error above for details.Make sure you have an Android emulator running or a device connected and haveset up your Android development environment:https://facebook.github.io/react-native/docs/android-setup.htmljax$ adb devicesList of devices attached192.168.56.101:5555 device 解决方案：首先，你应该检查你android/gradlew的权限，应该是755而不是644，然后在你的根目录执行：1chmod 755 android/gradlew 1、当把RN项目从一个目录移动到另一个目录时，run-ios时可能会出现异常：1error: PCH was compiled with module cache path 解决方案：在项目根目录下执行1rm -rf ios/build/ModuleCache/* 然后再react-native run-ios,搞定。 2、当react-native unlink xxxx某些模块是，会出现search.filter not a function的异常，解决方案：找到ios/项目名.xcodeproj/project.pbxproj，并用webstorm等非xocde编译器打开，然后全局搜索“$(inherited)”，将其替换成(“$(inherited)”)。注意：是当前search path下只存在”$(inherited)”一个的情况下。 3、RN版本0.45以后经常会出现一些third-party的问题，比如：third-party: ‘config.h’ file not found解决方案： 在项目根目录下执行：（不一定是这个路径，具体看third-party下的glog版本） 1cd node_modules/react-native/third-party/glog-0.3.4 执行 1../../scripts/ios-configure-glog.sh Glog配置完成，xcode也会找到config.h头文件了。]]></content>
      <categories>
        <category>React-Native</category>
      </categories>
      <tags>
        <tag>踩坑之旅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年终总结]]></title>
    <url>%2F2016%2F12%2F10%2F2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[流光容易把人抛，红了樱桃，绿了芭蕉。 &emsp;&emsp;人们总是在感叹时光的飞逝，岁月的无情，眼看它红樱桃，眼看它绿芭蕉，总想着从明天开始我要如何努力的迎头赶上。可是今天还长，明天还远，自己定下的明天一直没有来到，无限颓废的今天一直过不去。 &emsp;&emsp;转眼一年即逝，既为慰藉逝去的一年，也为总结得失，故写一下这些流水账于此。 关键词：年初；商城；山东济南；投资？；Ionic；上线； &emsp;&emsp;年初，我们离开了丰瑞祥，创办了一家小公司，之于说公司，倒不如说是工作室。余、晋、郭、张、黄、李，我们七个人，郭主外，负责市场部，其余的除了余之外的我们几个主内负责技术研发。公司成立伊始，其实尚不足我们7个，只有晋和郭我们三个，当时接了一个山东大学的项目，做一个线上的商城和发布活动的app，android &amp; ios &amp; 微网站，项目总共下来30万左右吧，开发周期定的是一个月。时间紧！任务重！考虑到这些因素，我们当时就用了跨平台的技术框架Ionic！由于我们在北京这边当时也没办公地点，郭也正好在山东找了一个投资，说是如果能完成这个项目，就会投钱给我们，所以我们当时就直奔山东济南了。 &emsp;&emsp;刚去的几天，我和晋住的是宾馆，一天好像是150块钱，郭男朋友在山东，所以她不和我们一起住。由于白天要去投资方的公司去上班，所以就租住在离公司不远的地方，150块钱租的地方环境并不好，一到晚上隔壁房间还很闹，我们晚上完全没办法工作，几经商议后，我们退了宾馆租了一个两居室，为期一月，3000元。环境很好，熬夜也很多，由于我们之前还是有一些商城的开发经验的，所以项目的开发过程也很顺利。一个月内，完成了三个平台的应用上线！ &emsp;&emsp;呼~项目上线了，终于可以松一口气了。可是这个时候，投资方却传来消息说公司账务问题可能没办法注资给我们了。言下之意也很明显，也许是看我们团队太小，也可能是滋生了其他想法，反正就是不投钱了。无论如何，他们也还是对我们有所帮助的，在此致谢。 &emsp;&emsp;项目完成了，晋思家心切，我也思霾心切（MDZZ?），于是我们就返京了。 关键词：北京；VR；地下室；内蒙；奶牛；mac book pro；’郭’离开； &emsp;&emsp;啊，北京！还是熟悉的配方，熟悉的味道。闻着北京厚重的雾霾味道，我们回来了！ &emsp;&emsp;返京之前，余和郭在上地三街那边找了一个孵化器，孵化器内公司主要是做VR，不管怎样，我们暂时安定下来了。回到北京的这段时间，断断续续的维护了一段时间山东的那个商城项目，当时也感觉到了VR的火热，我们团队也有意想朝VR的这个方面去做，但是奈何我们都没有相关方面的经验，只好作罢。这时郭也正好拿到一个内蒙与牛相关的项目，但是需要去内蒙那边考核一下，实地感受一下牧民朋友和牛的热情（？？？）。 蓝蓝的天空 清清的湖水 哎耶绿绿的草原 这是我的家 哎耶奔驰的骏马 洁白的羊群 哎耶还有你姑娘 这是我的家 哎耶 腾格尔《天堂》 &emsp;&emsp;到了内蒙才知道，这个词里面唱的真的是真的！不过，内蒙的大哥们喝酒真的是豪爽，见面先三碗内蒙原浆。去了内蒙三天，没有一天晚上是竖着回酒店的。。。值得一提的是回京的时候，我们租了一辆SUV从内蒙的乡下一路开车回赤峰机场，在一望无际的公路上一路狂奔，简直不要太爽！ &emsp;&emsp;项目推进过程中，我们内部却因为公司这段时间运营的还不错，开始在股份分配方面产生了分歧，最后没有谈拢，郭选择离开，并且带走了之前她接的山东和内蒙的项目，向我们支付了一些劳动报酬。其中是非对错我不想过多描述。 &emsp;&emsp;余这段时间也拿到了一个pos机相关的项目，由于pos机也是新型的android系统，技术选型还是定为Ionic，我也买了人生中第一本mac；虽然有项目在做，但是我们团队当时确实也感到了创业的艰难，于是项目做完之后，至7月底，我们团队整体就进入了元银国际。 关键词：元银国际；直播；react-native； &emsp;&emsp;进入元银国际之后开始了第一个项目就是以直播为主题的app，由于之前用的Ionic在性能上的问题还是很大，于是当时就在技术选型上商议了很久，最终定为react-native，然而我和晋当时都没有这方面的开发经验，于是就开始了边学边做的开发过程。开发过程中，困难重重也受益良多。 &emsp;&emsp;这一年过的很快，在技术方面，从java转向了nodejs，然后自学了react-native，也开发了两个上架的app，近期目标是学习android原生开发，不断丰富完善自己的技术栈。向着全栈前进！！！]]></content>
      <categories>
        <category>Summary</category>
      </categories>
      <tags>
        <tag>又是一年</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android打渠道包]]></title>
    <url>%2F2016%2F12%2F10%2Fandroid%E6%89%93%E6%B8%A0%E9%81%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[首先需要在android/app/build.gradle裡面添加一下命令： productFlavors {多渠道打包 android {}安卓市场 c360 {}360市场 xiaomi {}小米市场 yingyongbao {}应用宝 flyme {}魅族flyme市场 wandoujia {}豌豆荚 anzhi {}安智市场 lenovo {}联想 huawei {}华为 yingyonghui {}应用汇 jifeng {}机锋市场 sougou {}搜狗市场 oppo {}oppo市场 uc {}UC商店/PP助手/淘宝助手 pp {}PP助手 mumayi {}木蚂蚁 vivo {}vivo jinli {}金立 souhu {}搜狐 baidu {}百度市场 productFlavors.all { flavor -&gt; flavor.manifestPlaceholders = [APP_CHANNEL: name] } } app/build.gradle 如果用到了友盟等統計插件的話，然後删除manifestPlaceholders里面的APP_CHANNEL,AndroidManifest.xml里面添加： 12&lt;meta-data android:value=&quot;$&#123;APP_CHANNEL&#125;&quot; android:name=&quot;UMENG_CHANNEL&quot;/&gt;]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
</search>
